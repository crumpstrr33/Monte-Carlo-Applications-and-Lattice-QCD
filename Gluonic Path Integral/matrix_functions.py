'''
In this file, the class Matrix_nxn allows for certain operations and matrix 
creation for a specific n. The class Matrix_Const contains some common matrix
constants that may be needed.
'''
import numpy as np
import cmath
import math

j = cmath.sqrt(-1)

## Run the main program?
RUN = True


'''
Various functions for matrix creation/manipulation for dxd matrices with an
optional factor eps added as a multiplicative constant.
(defaults to 1 if not wanted)
'''
class Matrix_NxN(object):
    def __init__(self, d, eps=1):
        self.eps = eps
        self.d = d


    '''
    Creates an nxn Hermitian matrix with real/imaginary values between -1 and
    1 which can be tweaked as seen fit.
    '''
    def hermitian(self):
        c = 0
        x = np.random.uniform(-1, 1, self.d**2)
        H = np.array([0 + 0.j] * self.d**2).reshape((self.d, self.d))

        for i in range(self.d):
            H[i][i] = x[-(i + 1)] + 0.j
        for a in range(self.d - 1):
            for b in range(self.d - 1 - a):
                H[a][b + a + 1] = x[2*b + 2*c] + x[2*b + 2*c + 1]*j
                H[b + a + 1][a] = x[2*b + 2*c] - x[2*b + 2*c + 1]*j
            c += self.d - 1 - a

        return H


    '''    
    Creates an nxn Unitary matrix by estimating e^(iH) where H is a Hermitian
    matrix generated by the function hermitian.
    '''
    def unitary(self):
        H = self.hermitian()
        U = self.exp_est(H, 25)

        return U


    '''
    Creates an nxn SU(n) matrix by normalizing a unitary matrix with the dth
    root of the unitary matrix's determinant where d is the size of the matrix.
    '''
    def su_n(self):
        H = self.hermitian()
        U = self.exp_est(H, 25)
        SU3 = U / np.linalg.det(U)**(1/self.d)

        return SU3


    '''
    Estimates e^(i*a*M) for some matrix M and some constant a to n terms. With
    n = 25, it's a good balance, as the error and the computational time both
    very small, but it can be changed as n is an input variable.
    '''
    def exp_est(self, H, n):
        exp_tot = 0

        for k in range(n):
            exp_tot += (j * self.eps)**k / math.factorial(k) * \
                                           np.linalg.matrix_power(H, k)
        return exp_tot


    '''
    Returns the nth column of matrix.
    '''
    def col(self, n, matrix):
        col = []

        for i in range(self.d):
            col.append(matrix[i][n])

        return col


    '''
    (WIP: Does not work yet!) Orthonormalizes the columns of a dxd matrix.
    '''
    def gram_schmidt(self, mat):
        n = self.d
        norms = []
        n_mat = np.array([0. + 0.j] * n**2).reshape((n,n))

        for i in range(n):
            n_mat[i][0] = self.col(0, mat)[i]
        for i in range(n):
            for j in range(n):
                n_mat[j][i] = self.col(i, mat)[j]
                for k in range(i):
                    n_mat[k][i] += np.vdot(self.col(i, n_mat), self.col(k, n_mat)) \
                                / np.vdot(self.col(k, n_mat), self.col(k, n_mat)) \
                                * self.col(k, n_mat)[k]

        for i in range(n):
            norms.append(np.linalg.norm(self.col(i, n_mat)))
        for i in range(n):
            for j in range(n):
                n_mat[i][j] /= norms[i]

        return n_mat


    '''
    Returns a dxd identity matrix.  
    '''
    def I(self):
        iden = self.zero()
        for i in range(self.d):
            iden[i][i] = 1 + 0.j
        return iden


    '''
    Creates a dxd zero matrix.
    '''    
    def zero(self):
        return np.array([0 + 0.j] * self.d**2).reshape((self.d, self.d))


'''
Common matrix constants.
'''
class Matrix_Const(object):
    def __init__(self):
        '''
        Pauli Matrices
        '''
        self.pm1 = np.array([0 + 0.j, 1 + 0.j,
                             1 + 0.j, 0 + 0.j])
        self.pm2 = np.array([0 + 0.j, 0 - 1.j,
                             0 + 1.j, 0 + 0.j])
        self.pm3 = np.array([1 + 0.j, 0 + 0.j,
                             0 + 0.j, -1 + 0.j])
        self.pmList = np.array([self.pm1, self.pm2, self.pm3])


        '''
        Gell-Mann Matrices.
        '''        
        self.gm1 = np.array([0 + 0.j,  1 + 0.j,  0 + 0.j,
                             1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm2 = np.array([0 + 0.j,  0 - 1.j,  0 + 0.j,
                             0 + 1.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))                         
        self.gm3 = np.array([1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j, -1 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm4 = np.array([0 + 0.j,  0 + 0.j,  1 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j,
                             1 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm5 = np.array([0 + 0.j,  0 + 0.j,  0 - 1.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 1.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm6 = np.array([0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  1 + 0.j,
                             0 + 0.j,  1 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm7 = np.array([0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 - 1.j,
                             0 + 0.j,  0 + 1.j,  0 + 0.j]).reshape((3,3))
        self.gm8 = np.array([1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  1 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j, -2 + 0.j]).reshape((3,3)) / np.sqrt(3)
        self.gmList = np.array([self.gm1, self.gm2, self.gm3,
                                self.gm4, self.gm5, self.gm6,
                                self.gm7, self.gm8])


'''
Main function
'''
def main():
    num_mat = 100000
    su3_list = []
    dets_re = []
    dets_im = []
    
    ## What size matrix you want?
    M = Matrix_NxN(3) 

    ## Creates numMatrices matrices.
    for i in range(num_mat):
        su3_list.append(M.su_n())

    ##Creates lists for the real and imaginary parts of the determinants of
    ## each matrix.
    for i in su3_list:
        dets_re.append(np.real(np.linalg.det(i)))
        dets_im.append(np.imag(np.linalg.det(i)))

    ## Prints out the averages/standard deviations of these lists, used
    ## primarily for troubleshooting.
    print('Imaginary')
    print('Average:', np.average(dets_im))
    print('Standard Deviation:', np.std(dets_im), '\n')

    print('Real:')
    print('Average:', np.average(dets_re))
    print('Standard Deviation:', np.std(dets_re), '\n')

    ## Plots the real part of the trace of each matrix versus the imaginary
    ## part. Makes a cool concave triangle thing for d=3. Generally, creates
    ## a concave shape with d vertices.
    im_trace = []
    re_trace = []
    for i in range(num_mat):
        im_trace.append(np.imag(np.trace(su3_list[i])))
        re_trace.append(np.real(np.trace(su3_list[i])))

    import matplotlib.pyplot as plt
    plt.figure()
    plt.xlabel('ReTr(M)')
    plt.ylabel('ImTr(M)')
    plt.xlim(-2, 3)
    plt.ylim(-3, 3)
    plt.scatter(re_trace, im_trace, s = 1, color = 'b')

    ## To print 'matrix' with a limited number of decimal points
    # matrix = np.array([x.__format__('.3f') for x in
    #                                        matrix.flatten()]).reshape((3,3))

  
if __name__ == "__main__":
    ## Runs the main function based on value of RUN
    if RUN:
        main()


## Grahm-Schmidt process for 3x3, commented out for refence.
'''
def orthonormalize(self, matrix):
    newmatrix = ((np.zeros(9) + 0 * j).reshape((3,3)))

    ## Replaces the first column
    for i in range(3):
        newmatrix[i][0] = self.col(0, matrix)[i]

    ## Replaces the second column
    for i in range(3):
        newmatrix[i][1] = self.col(1, matrix)[i] - np.vdot(self.col(0, newmatrix), self.col(1, matrix))  \
                                                 / np.vdot(self.col(0, newmatrix), self.col(0, newmatrix))  \
                                                         * self.col(0, newmatrix)[i]

    ## Replaces the third column
    for i in range(3):
        newmatrix[i][2] = self.col(2, matrix)[i] - np.vdot(self.col(0, newmatrix), self.col(2, matrix))  \
                                                 / np.vdot(self.col(0, newmatrix), self.col(0, newmatrix))  \
                                                         * self.col(0, newmatrix)[i]  \
                                                 - np.vdot(self.col(1, newmatrix), self.col(2, matrix))  \
                                                 / np.vdot(self.col(1, newmatrix), self.col(1, newmatrix))  \
                                                         * self.col(1, newmatrix)[i]
    
    ## Normalizes the columns   
    normCol1 = np.linalg.norm(self.col(0, newmatrix))
    normCol2 = np.linalg.norm(self.col(1, newmatrix))
    normCol3 = np.linalg.norm(self.col(2, newmatrix))

    for i in range(3):
        newmatrix[i][0] /= normCol1
        newmatrix[i][1] /= normCol2
        newmatrix[i][2] /= normCol3

    return newmatrix
'''
