'''
In this file, the class MatrixNxN allows for certain operations and matrix 
creation for a specific d. The class MatrixConst contains some common matrix
constants that may be needed.
'''
import numpy as np
import cmath
import math

j = cmath.sqrt(-1)

## Run the main program?
RUN = False


class MatrixNxN(object):
    '''
    Various functions for matrix creation/manipulation for dxd matrices.
    '''
    def __init__(self, d, eps=1):
        '''
        Parameters:
        d - the dimension of the matrix (dxd)
        eps - (optional) a multiplicative factor when estimating the
              exponential of a matrix, defaults to 1.
        '''
        self.eps = eps
        self.d = d


    def hermitian(self, min_val=-1, max_val=1):   
        '''
        Parameters:
        min_val - (optional) the minimum value allowed for the real and
                  imaginary part (is not the min value for the norm)
        max_val - (optional) the maximum value allowed for the real and
                  imaginary part (is not the max value for the norm)
        Returns:
        H - a complex dxd Hermitian matrix

        Creates an nxn Hermitian matrix with real/imaginary values uniformly
        distributed between min_val and max_val.
        '''
        H = np.random.uniform(min_val, max_val, (self.d, self.d)) + \
            np.random.uniform(min_val, max_val, (self.d, self.d)) * j
        H = (H + np.conj(H.T)) / 2

        return H


    def unitary(self):
        '''
        Returns:
        U - a complex dxd Unitary matrix

        Creates an dxd Unitary matrix by estimating e^(iH) where H is a
        Hermitian matrix generated by the function self.hermitian.
        '''
        H = self.hermitian()
        U = self._exp_est(H, 25)

        return U


    def sun(self):
        '''
        Returns:
        SUd - a complex dxd SU(d) matrix

        Creates an nxn SU(n) (for n=d) matrix by normalizing a unitary matrix
        with the dth root of the unitary matrix's determinant where d is the
        size of the matrix.
        '''
        H = self.hermitian()
        U = self._exp_est(H)
        SUd = U / np.linalg.det(U)**(1 / self.d)

        return SUd


    def _exp_est(self, H, n=25):
        '''
        Parameters:
        H - a dxd matrix. The variable H is used because this function is used
            for calculating a Unitary matrix by exponentiating a Hermitian
            matrix
        n - (optional) the number of terms to estimate the sum to
        Returns:
        exp_tot - the estimation of the exponential

        Estimates e^(i*a*M) by expanding it's Taylor seris for some matrix M
        and some constant a to n terms. With n = 25, it's a good balance, as
        the error and the computational time both very small, but it can be
        changed as n is an input variable.
        '''
        exp_tot = 0

        for k in range(n):
            exp_tot += (j * self.eps)**k / math.factorial(k) * \
                                           np.linalg.matrix_power(H, k)
        return exp_tot


    def gram_schmidt(self, mat, rows=True):
        '''
        Parameters:
        mat - any dxd matrix
        rows - (optional) if True, this function will orthonormalize the rows
               of the matrix but if False, it will orthonormalize the columns
               of the matrix.
        Returns:
        gm_mat - the orthonormalized matrix. If rows=False, the matrix is
                 returned transposed to restore the rows back as columns since
                 the function does calculations on the columns

        Orthonormalizes the row or columns of a dxd matrix via the Gram Schmidt
        process. The dimensions of the pass matrix must match that of the object
        otherwise nothing is returned.
        '''
        if rows:
            gm_mat = np.copy(mat).astype(complex)
        else:
            gm_mat = np.copy(mat).astype(complex).T

        if len(mat[0]) != self.d:
            print('Wrong matrix dimension: (%d, %d) for d=%d object'
                  % (gm_mat.shape[0], gm_mat.shape[1], self.d))
            return
    
        for n in range(1, self.d):
            proj = 0
            for m in range(n):
                u, v = gm_mat[m], gm_mat[n]
                proj += np.dot(v, u) / np.dot(u, u) * u
            gm_mat[n] -= proj
            
        gm_mat /= np.linalg.norm(gm_mat, axis=1)[:, None]

        if rows:
            return gm_mat
        else:
            return gm_mat.T


    def rand_mat(self, is_complex=True, dtype='float', max_val=5, min_val=-5,
                 distribution='uniform', mean=0, std=1, **kwargs):
        '''
        Parameters:
        is_complex - (optional) if True, this function will add an imaginary
                     part to each element of the matrix but if False, every
                     element will remain real
        dtype - (optional) determines the type of each number should be. Can be
                'float' for floats or 'int' for ints.
        max_val - (optional) the maximum value allowed for each element (if
                  is_complex=True, then, for each element a+ib, a and b will
                  both be strictly less than max_val)
        min_val - (optional) the minimum value allowed for each element (if
                  is_complex=True, then, for each element a+ib, a and b will
                  both be strictly greater than min_val)
        distribution - (optional) determines the random process in which the
                       values of the matrix are chosen. Can be 'uniform' for a 
                       uniform distribution or 'normal' for a normal
                       distribution.
        mean - (optional) if distribution='normal', then this is the mean used
               for the normal distribution
        std - (optional) if distribution='normal', then this is the std used
              for the normal distribution
        Returns:
        mat - random dxd matrix

        Creates a random dxd matrix with properties given.
        '''
        s = (self.d, self.d)
        mav, miv = max_val, min_val

        if distribution == 'uniform':
            mat = (dtype == 'float') * np.random.uniform(miv, mav, s) + \
                  (dtype == 'int') * np.random.uniform(miv, mav, s).astype(int)

            if is_complex:
                mat = mat.astype('complex')
                mat += (dtype == 'float') * np.random.uniform(miv, mav, s) * j + \
                       (dtype == 'int') * np.random.uniform(miv, mav, s).astype(int) * j
        elif distribution == 'normal':
            mat = (dtype == 'float') * np.random.normal(mean, std, s) + \
                  (dtype == 'int') * np.random.normal(mean, std, s).astype(int)

            if is_complex:
                mat = mat.astype('complex')
                mat += (dtype == 'float') * np.random.normal(mean, std, s) * j + \
                      (dtype == 'int') * np.random.normal(mean, std, s).astype(int) * j
        else:
            print('The distribution \'%s\' not understood' % distribution)
            return

        if np.sum(mat) == 0:
            print('The dtype \'%s\' not understood' % dtype)
            return
            
        if kwargs is not None:
            for key in kwargs:
                print('There\'s no option for \'%s\', maybe there should be.' % key)

        return mat


    def I(self, dtype=complex):
        '''
        Parameters:
        dtype - (optional) data type for the matrix

        Returns a dxd complex identity matrix.  
        '''
        return np.eye(self.d, dtype=dtype)

  
    def zero(self, dtype=complex):
        '''
        Parameters:
        dtype - (optional) data type for the matrix
        
        Creates a dxd complex zero matrix.
        '''  
        return np.zeros((self.d, self.d), dtype=dtype)


'''
Common matrix constants.
'''
class MatrixConst(object):
    def __init__(self):
        '''
        Pauli Matrices
        '''
        self.pm1 = np.array([0 + 0.j, 1 + 0.j,
                             1 + 0.j, 0 + 0.j])
        self.pm2 = np.array([0 + 0.j, 0 - 1.j,
                             0 + 1.j, 0 + 0.j])
        self.pm3 = np.array([1 + 0.j, 0 + 0.j,
                             0 + 0.j, -1 + 0.j])
        self.pmList = np.array([self.pm1, self.pm2, self.pm3])


        '''
        Gell-Mann Matrices.
        '''        
        self.gm1 = np.array([0 + 0.j,  1 + 0.j,  0 + 0.j,
                             1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm2 = np.array([0 + 0.j,  0 - 1.j,  0 + 0.j,
                             0 + 1.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))                         
        self.gm3 = np.array([1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j, -1 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm4 = np.array([0 + 0.j,  0 + 0.j,  1 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j,
                             1 + 0.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm5 = np.array([0 + 0.j,  0 + 0.j,  0 - 1.j,
                             0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 1.j,  0 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm6 = np.array([0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  1 + 0.j,
                             0 + 0.j,  1 + 0.j,  0 + 0.j]).reshape((3,3))
        self.gm7 = np.array([0 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j,  0 - 1.j,
                             0 + 0.j,  0 + 1.j,  0 + 0.j]).reshape((3,3))
        self.gm8 = np.array([1 + 0.j,  0 + 0.j,  0 + 0.j,
                             0 + 0.j,  1 + 0.j,  0 + 0.j,
                             0 + 0.j,  0 + 0.j, -2 + 0.j]).reshape((3,3)) / np.sqrt(3)
        self.gmList = np.array([self.gm1, self.gm2, self.gm3,
                                self.gm4, self.gm5, self.gm6,
                                self.gm7, self.gm8])


'''
Main function
'''
def main():
    num_mat = 10000
    su3_list = []
    dets_re = []
    dets_im = []
    
    ## What size matrix you want?
    M = MatrixNxN(3) 

    ## Creates numMatrices matrices.
    for i in range(num_mat):
        su3_list.append(M.sun())

    ##Creates lists for the real and imaginary parts of the determinants of
    ## each matrix.
    for i in su3_list:
        dets_re.append(np.real(np.linalg.det(i)))
        dets_im.append(np.imag(np.linalg.det(i)))

    ## Prints out the averages/standard deviations of these lists, used
    ## primarily for troubleshooting.
    print('Imaginary')
    print('Average:', np.average(dets_im))
    print('Standard Deviation:', np.std(dets_im), '\n')

    print('Real:')
    print('Average:', np.average(dets_re))
    print('Standard Deviation:', np.std(dets_re), '\n')

    ## Plots the real part of the trace of each matrix versus the imaginary
    ## part. Makes a cool concave triangle thing for d=3. Generally, creates
    ## a concave shape with d vertices.
    im_trace = []
    re_trace = []
    for i in range(num_mat):
        im_trace.append(np.imag(np.trace(su3_list[i])))
        re_trace.append(np.real(np.trace(su3_list[i])))

    import matplotlib.pyplot as plt
    plt.figure()
    plt.xlabel('ReTr(M)')
    plt.ylabel('ImTr(M)')
    plt.xlim(-2, 3)
    plt.ylim(-3, 3)
    plt.scatter(re_trace, im_trace, s = 1, color = 'b')

    ## To print 'matrix' with a limited number of decimal points
    # np.array([x.__format__('.3f') for x in matrix.flatten()]).reshape((3,3))

  
if __name__ == "__main__":
    ## Runs the main function based on value of RUN
    if RUN:
        main()